#This file reads into an unpacked ragnarok online client
#extracts keys used for packet XORing
#extracts packets length
#checks expected packets sizes
#if everything seems correct, builds Send.pm and Receive.pm for bRO
#
#
#Criando diretorios 
open HEX, "<", "Ragexe.pb.1.exe" or die $!;
mkdir 'tables';
mkdir 'tables/bro';
mkdir 'src';
mkdir 'src/Network';
mkdir 'src/Network/Receive';
mkdir 'src/Network/Send';
#open NAH, ">nah.txt";
binmode HEX;


#######requires unpacked ragexe file

# Step 1. find XOR keys 
while (<HEX>) {
	# Generates a Hex Dump from target EXE
	my $tempDump = unpack("H*",$_);
	# Hex Dump is way too large, so we cut it down to where the packets are, thus decreasing process time:
	# Beginning of packets		
#print NAH "$tempDump";
	#if ($tempDump =~ /558bec81ec380b0000568bf1/i) {	
	#	print "sleep1\n";
	#	$flagWrite = 1
	#}	
	#if ($flagWrite) {
		$HexDump .= $tempDump;
	#}
	# Ending of packets
	# Note: flagWrite must be set to undef AFTER the writing process above, or else it won't write the last packet's block
	#if ($tempDump =~ /e8b295ffff5e8be55dc3cccccccccccc/i) {
	#print "sleep2\n";
	#	$flagWrite = undef;
	#}
	# This extracts bRO's encrypting keys (K, M, A) into an array
	if ($tempDump =~ m/25FF7F00005DC2040083F801751BC74104(..)(..)(..)(..)C74108(..)(..)(..)(..)C7410C(..)(..)(..)(..)33C05DC20400/i) {
	
		print "sleep3\n";
		#sleep(20);
		push(@keys, (uc($4.$3.$2.$1), uc($8.$7.$6.$5), uc($12.$11.$10.$9)));
		push(@keys01, (map hex, $keys[0]));
		push(@keys02, (map hex, $keys[1]));
		push(@keys03, (map hex, $keys[2]));
		
		
	}
}
close HEX;

# Step 2. generate recvpackets.txt 
# This was firstly designed to bRO, so it is likely that only post-renewall EXE's would work with it
# First we grab the general packets in the WHILE, then we analyze the kind of packet in the IF's
$datestring = localtime();
open RECV, ">recvpackets.txt";
#print RECV "# Generated by FullMetal extracting tool $datestring\n";
#print RECV "\n\n $HexDump\n\n\n";
open Len, "<", "Len.txt" or die $!;
my $tempMatch = "$HexDump";


#while ($tempMatch =~ m/(C745FC|68)(..)(..)0000(8B|89|C7|B8)/ig) {
#while ($tempMatch =~ m/(C745FC|z68)(..)(..)0000(8B|89|C7|B8)/ig) {

#while ($tempMatch =~ m/c745f0(..)(..)0000(8d45f4508d45f0508d45dc50)?c745f4(..)(..)0000c745f8(..)(..)0000c745fc(..)(..)0000|6a(..)6a(..)6a(..)68(..)(..)00008bcee8/ig) {
while ($tempMatch =~ m/c745(?:f0|fc)(..)(..)0000(8d45f4508d45f0508d45dc50)?c745(?:f4|f0)(..)(..)(0000|ffff)(?:8d45f4508d45f0508d45dc50)?c745(?:f8|f4)(..)(..)0000(?:8d45f4508d45f0508d45dc50)?c745(?:fc|f8)(..)(..)0000|6a(..)(?:68(..)(..)0000|6a(..))(?:68(..)(..)0000|6a(..))(?:68(..)(..)0000|6a(..))8bcee8/ig) {
#my $PackID = uc($3.$2);
		print "sleep4\n";
#my $line = <Len>;
my $packet;
if (defined $9) {
print $2, " ",$1, " ",$5, " ",$4, " ",$8, " ",$7, " ",$10, " ",$9, "\n";
	$packet = uc($2.$1) . " ";
	$tmp1 = hex ($5.$4) . " ";
	$tmp2 = hex ($8.$7) . " " . hex ($10.$9) . "\n";
	next if ($packet =~ /0000/);
	if ($6 =~ /ffff/i) {
		$packet .= "-1 ";
	} else {
		$packet .= $tmp1;
		next if (($5.$4) != ($8.$7));
	}
	$packet .= $tmp2;
	
} elsif (defined $11) {
print $15, " ",$14, " ",$13, " ",$12, " ",$11, "\n ";
	$digit1;
	$digit2;
	$digit3 = hex ($11);
	next if ($digit3 > 1 || $digit3  < 0);
	
	if (defined $12) {
		$digit2 = hex ($13.$12);
	} else {
		$digit2 = hex ($14);
	}
	
	if (defined $15) {
		$digit1 = hex ($16.$15);
		if (uc($15) eq "FF") {
			$digit1 = -1;
		}
	} else {
		$digit1 = hex ($17);
		if (uc($17) eq "FF") {
			$digit1 = -1;
		}
	}
	
	next if ($digit1 > -1 && $digit2 != $digit1);
	
	if (defined $20) {
		$packet = "00" . uc($20) . " ";
		next if ($digit3 > 1 || $digit3  < 0);
		next if ((uc($20) eq "FF"|uc($20) eq "04")&& $digit1 == 0 && $digit2 == 0 && $digit3 == 0 );
		next if (uc($20) eq "01" && $digit1 == 1 && $digit2 == 1 && $digit3 == 1 );
		next if (uc($20) eq "7F" && $digit1 == -1 && $digit2 == 0 && $digit3 == 0 );
	} else {
		$packet = uc($19.$18) . " ";
	}
	next if ($packet =~ /0000/);
	$packet .= $digit1 . " " . $digit2 . " " . $digit3 . "\n";
} else {
	
		print "sleep6\n";
}

print RECV $packet;

foreach my $Length (@line) {
}
close(arq);
}

#print hex 'FFFFFFFF' ;
#print RECV "0073 11 11 1
#0074 3 3 0
#0075 -1 11 1
#0076 9 9 1
#0077 5 5 1
#0078 55 55 1
#007A 58 58 1
#007B 60 60 1
#007C 44 44 1
#007F 6 6 1";

close RECV;



# Stores new packets into array to be used by bro.pm generator #$delta may change between file versions
open RECV, "<", "recvpackets.txt" or die $!;
$error = 0;
$cont = 0;
$delta = 1118;
while (my $line = <RECV>) {
	if (substr($line,0,1) !~ /\s|\#/) {
		$cont++;
		if ($cont-$delta == 1) { # actor_action
			if ($line =~ /7 7 0/) { #
				push(@newPackets,substr($line,0,4));
			} else {
				$error = 1;
			}
		} elsif ($cont-$delta == 3) { # character_move
			if ($line =~ /5 5 0/) {
				push(@newPackets,substr($line,0,4));
			} else {
				$error = 1;
			}
		} elsif ($cont-$delta == 2) { # skill_use
			if ($line =~ /10 10 0/) {
				push(@newPackets,substr($line,0,4));
			} else {
				$error = 1;
			}
		} elsif ($cont-$delta == 4) { # sync
			if ($line =~ /6 6 0/) {
				push(@newPackets,substr($line,0,4));
			} else {
				$error = 1;
			}
		} elsif ($cont-$delta == 5) { # actor_look_at
			if ($line =~ /5 5 0/) {
				push(@newPackets,substr($line,0,4));
			} else {
				$error = 1;
			}
		} elsif ($cont-$delta == 6) { # item_take
			if ($line =~ /6 6 0/) {
				push(@newPackets,substr($line,0,4));
			} else {
				$error = 1;
			}
		} elsif ($cont-$delta == 7) { # item_drop
			if ($line =~ /6 6 0/) {
				push(@newPackets,substr($line,0,4));
			} else {
				$error = 1;
			}
		} elsif ($cont-$delta == 8) { # storage_item_add
			if ($line =~ /8 8 0/) {
				push(@newPackets,substr($line,0,4));
			} else {
				$error = 1;
			}
		} elsif ($cont-$delta == 9) { # storage_item_remove
			if ($line =~ /8 8 0/) {
				push(@newPackets,substr($line,0,4));
			} else {
				$error = 1;
			}
		} elsif ($cont-$delta == 10) { # skill_use_location
			if ($line =~ /10 10 0/) {
				push(@newPackets,substr($line,0,4));
			} else {
				$error = 1;
			}
		} elsif ($cont-$delta == 12) { # actor_info_request
			if ($line =~ /6 6 0/) {
				push(@newPackets,substr($line,0,4));
			} else {
				$error = 1;
			}
		} elsif ($cont-$delta == 13) { # actor_name_request
			if ($line =~ /6 6 0/) {
				push(@newPackets,substr($line,0,4));
			} else {
				$error = 1;
			}
		} elsif ($cont-$delta == 23) { # item_list_res
			if ($line =~ /-1 12 0/) {
				push(@newPackets,substr($line,0,4));
			} else {
				$error = 1;
			}
		} elsif ($cont-$delta == 24) { # map_login
			if ($line =~ /19 19 0/) {
				push(@newPackets,substr($line,0,4));
			} else {
				$error = 1;
			}
		} elsif ($cont-$delta == 25) { # party_join_request_by_name
			if ($line =~ /26 26 0/) {
				push(@newPackets,substr($line,0,4));
			} else {
				$error = 1;
			}
		} elsif ($cont-$delta == 28) { # homunculus_command
			if ($line =~ /5 5 0/) {
				push(@newPackets,substr($line,0,4));
			} else {
				$error = 1;
			}
		} elsif ($cont-$delta == 29) { # storage_password
			if ($line =~ /36 36 0/) {
				push(@newPackets,substr($line,0,4));
			} else {
				$error = 1;
			}
		} elsif (($cont-$delta > 29) && ($cont-$delta < 114)) {
			if ($line =~ /2 2 0/) {
				push(@recvPacketslist,substr($line,0,4));
			} else {
				$error = 1;
			}
		} elsif (($cont-$delta > 113) && ($cont-$delta < 198)) {
			if ($line =~ /2 2 0/) {
				push(@sendPacketslist,substr($line,0,4));
			} else {
				$error = 1;
			}
		}
	}
	last if (($error == 1));
}
close RECV;

$old_name=recvpackets.txt;
$new_name="tables\recvpackets.txt";
rename $old_name, $new_name;

## generates send.pm

if ($error == 1) {
	print "Ocorreu um erro na linha ", $cont, ". Comparacao: ", $cont-$delta;
} else {

	open (SEND, '>sendbro.pm');
	print SEND "#############################################################################
#  OpenKore - Network subsystem												#
#  This module contains functions for sending messages to the server.		#
#																			#
#  This software is open source, licensed under the GNU General Public		#
#  License, version 2.														#
#  Basically, this means that you're allowed to modify and distribute		#
#  this software. However, if you distribute modified versions, you MUST	#
#  also distribute the source code.											#
#  See http://www.gnu.org/licenses/gpl.html for the full license.			#
#############################################################################
# bRO (Brazil)
package Network::Send::bRO;
use strict;
use base 'Network::Send::ServerType0';

sub new {
	my (\$class) = \@_;
	my \$self = \$class->SUPER::new(\@_);
	
	my %packets = (
		'$newPackets[0]' => ['actor_action', 'a4 C', [qw(targetID type)]],
		'$newPackets[1]' => ['skill_use', 'v2 a4', [qw(lv skillID targetID)]],
		'$newPackets[2]' => ['character_move','a3', [qw(coords)]],
		'$newPackets[3]' => ['sync', 'V', [qw(time)]],
		'$newPackets[4]' => ['actor_look_at', 'v C', [qw(head body)]],
		'$newPackets[5]' => ['item_take', 'a4', [qw(ID)]],
		'$newPackets[6]' => ['item_drop', 'v2', [qw(index amount)]],
		'$newPackets[7]' => ['storage_item_add', 'v V', [qw(index amount)]],
		'$newPackets[8]' => ['storage_item_remove', 'v V', [qw(index amount)]],
		'$newPackets[9]' => ['skill_use_location', 'v4', [qw(lv skillID x y)]],
		'$newPackets[10]' => ['actor_info_request', 'a4', [qw(ID)]],
		'$newPackets[11]' => ['actor_name_request', 'a4', [qw(ID)]],
		'$newPackets[12]' => ['item_list_res', 'v V2 a*', [qw(len type action itemInfo)]],
		'$newPackets[13]' => ['map_login', 'a4 a4 a4 V C', [qw(accountID charID sessionID tick sex)]],
		'$newPackets[14]' => ['party_join_request_by_name', 'Z24', [qw(partyName)]], #f
		'$newPackets[15]' => ['homunculus_command', 'v C', [qw(commandType, commandID)]], #f
		'$newPackets[16]' => ['storage_password'],
	);
	
	\$self->{packet_list}{\$_} = \$packets{\$_} for keys %packets;
	
	my %handlers = qw(
		master_login 02B0
		buy_bulk_vender 0801
		party_setting 07D7
	);
	
	while (my (\$k, \$v) = each %packets) { \$handlers{\$v->[0]} = \$k}
	\$self->{packet_lut}{\$_} = \$handlers{\$_} for keys %handlers;
	\$self->cryptKeys(@keys01, @keys03, @keys02);

	return \$self;
}

1;";
	close SEND;

## generates receive.pm

	open (RECEIVE, '>receivebro.pm');
	print RECEIVE "#############################################################################
#  OpenKore - Network subsystem												#
#  This module contains functions for sending messages to the server.		#
#																			#
#  This software is open source, licensed under the GNU General Public		#
#  License, version 2.														#
#  Basically, this means that you're allowed to modify and distribute		#
#  this software. However, if you distribute modified versions, you MUST	#
#  also distribute the source code.											#
#  See http://www.gnu.org/licenses/gpl.html for the full license.			#
#############################################################################
# bRO (Brazil)
package Network::Receive::bRO;
use strict;
use Log qw(warning);
use base 'Network::Receive::ServerType0';


# Sync_Ex algorithm developed by Fr3DBr

sub new {
	my (\$class) = \@_;
	my \$self = \$class->SUPER::new(\@_);
	
	my %packets = (
		'0097' => ['private_message', 'v Z24 V Z*', [qw(len privMsgUser flag privMsg)]], # -1
)";
	
	print RECEIVE ";
# Sync Ex Reply Array 
	\$self->{sync_ex_reply} = {
";
	
	####################### generate sync_receive_ex tables

	
	for ($var = 0;$var < scalar(@recvPacketslist);$var++) {
		print RECEIVE "	'$recvPacketslist[$var]', '$sendPacketslist[$var]',"

	};
	####################### end of sync_receive_ex tables
	print RECEIVE "
	};
	
	foreach my \$key (keys %{\$self->{sync_ex_reply}}) { \$packets{\$key} = ['sync_request_ex']; }
	foreach my \$switch (keys %packets) { \$self->{packet_list}{\$switch} = \$packets{\$switch}; }
	return \$self;"

}

print ( RECEIVE"
}

sub items_nonstackable {
	my (\$self, \$args) = \@_;

	my \$items = \$self->{nested}->{items_nonstackable};

	if(\$args->{switch} eq '00A4' || \$args->{switch} eq '00A6' || \$args->{switch} eq '0122') {
		return \$items->{type4};
	} elsif (\$args->{switch} eq '0295' || \$args->{switch} eq '0296' || \$args->{switch} eq '0297') {
		return \$items->{type4};
	} elsif (\$args->{switch} eq '02D0' || \$args->{switch} eq '02D1' || \$args->{switch} eq '02D2') {
		return  \$items->{type4};
	} else {
		warning(\"items_nonstackable: unsupported packet (\$args->{switch})!\\n\");
	}
}

*parse_quest_update_mission_hunt = *Network::Receive::ServerType0::parse_quest_update_mission_hunt_v2;
*reconstruct_quest_update_mission_hunt = *Network::Receive::ServerType0::reconstruct_quest_update_mission_hunt_v2;

1;
");

	close RECEIVE;
	use File::Copy;
	copy("sendbro.pm", "src/Network/Send/bRO.pm") or die "falha na copia: $!"; 
	copy("receivebro.pm", "src/Network/Receive/bRO.pm") or die "falha na copia: $!"; 
	copy("recvpackets.txt", "tables/bRO/recvpackets.txt") or die "falha na copia: $!"; 
